include "../lib/leibniz.ptt"

Id : ∀ {A : U} → A → A → U
Id = λ x y ↦ ∀ (C : A → U) → C x → C y

refl : ∀ {A : U} (x : A) → Id x x
refl = λ x C Cx ↦ Cx

macro %refl 
  = λ _ Cx ↦ Cx

sym : ∀ (A : U) (x : A) (y : A) → Id x y → Id y x
sym = λ A x y x=y ↦ x=y (λ z ↦ Id z x) (refl x)

trans : ∀ (A : U) (x : A) (y : A) (z : A) → Id x y → Id y z → Id x z
trans = λ A x y z x=y y=z ↦ y=z (λ v ↦ Id x v) x=y

end-of-file "../lib/leibniz.ptt"

type %refl : Id {Code ⟦ U ⟧} ⟦ Unit → Unit ⟧ ⟦ Unit → Unit ⟧
  : Id {Code ⟦ U ⟧} ⟦ Unit → Unit ⟧ ⟦ Unit → Unit ⟧

fail %refl : Id {Code ⟦ U ⟧} ⟦ Unit → Unit ⟧ ⟦ Unit → U ⟧
  examples/staging/code-eq.ptt:5:6: Couldn't match types
    • expected: C ⟦ Unit → U ⟧
    • actual: C ⟦ Unit → Unit ⟧
    • not convertible (at level 0): U : U /= Unit
    • When checking that Cx has type C ⟦ Unit → U ⟧
    • When checking that λ Cx ↦ Cx has type C ⟦ Unit → Unit ⟧ → C ⟦ Unit → U ⟧
    • When checking that
      λ _ Cx ↦ Cx
      has type
      Id {Code ⟦ U ⟧} ⟦ Unit → Unit ⟧ ⟦ Unit → U ⟧
    • When infering type of
      (λ _ Cx ↦ Cx) : Id {Code ⟦ U ⟧} ⟦ Unit → Unit ⟧ ⟦ Unit → U ⟧

id : ∀ {A : U} → A → A
id = λ x ↦ x

type %refl
    : Id
      {Code ⟦ U ⟧}
      ⟦ let x = Unit in id {U} Unit ⟧
      ⟦ let x = Unit in id {U} Unit ⟧
  : Id
    {Code ⟦ U ⟧}
    ⟦ let x = Unit : U in id {U} Unit ⟧
    ⟦ let x = Unit : U in id {U} Unit ⟧

fail %refl
    : Id
      {Code ⟦ U ⟧}
      ⟦ let x = Unit in id {U} Unit ⟧
      ⟦ let x = Unit in id {U} x ⟧
  examples/staging/code-eq.ptt:12:6: Couldn't match types
    • expected: C ⟦ let x = Unit : U in id {U} x ⟧
    • actual: C ⟦ let x = Unit : U in id {U} Unit ⟧
    • not convertible (at level 0): U : !0 /= Unit
    • When checking that Cx has type C ⟦ let x = Unit : U in id {U} x ⟧
    • When checking that
      λ Cx ↦ Cx
      has type
      C ⟦ let x = Unit : U in id {U} Unit ⟧ → C ⟦ let x = Unit : U in id {U} x ⟧
    • When checking that
      λ _ Cx ↦ Cx
      has type
      Id
        {Code ⟦ U ⟧}
        ⟦ let x = Unit : U in id {U} Unit ⟧
        ⟦ let x = Unit : U in id {U} x ⟧
    • When infering type of
      (λ _ Cx ↦ Cx)
        : Id
          {Code ⟦ U ⟧}
          ⟦ let x = Unit in id {U} Unit ⟧
          ⟦ let x = Unit in id {U} x ⟧

type %refl
    : Id {Code ⟦ Unit ⟧} ⟦ let x = tt : Unit in x ⟧ ⟦ let x = tt : Unit in x ⟧
  : Id {Code ⟦ Unit ⟧} ⟦ let x = tt : Unit in x ⟧ ⟦ let x = tt : Unit in x ⟧

type %refl
    : Id
      {Code ⟦ Unit ⟧}
      ⟦ let x = tt : Unit in let y = tt : Unit in x ⟧
      ⟦ let u = tt : Unit in let v = tt : Unit in u ⟧
  : Id
    {Code ⟦ Unit ⟧}
    ⟦ let x = tt : Unit in let y = tt : Unit in x ⟧
    ⟦ let u = tt : Unit in let v = tt : Unit in u ⟧

fail %refl
    : Id
      {Code ⟦ Unit ⟧}
      ⟦ let x = tt : Unit in let y = tt : Unit in x ⟧
      ⟦ let u = tt : Unit in let v = tt : Unit in v ⟧
  examples/staging/code-eq.ptt:22:6: Couldn't match types
    • expected: C ⟦ let u = tt : Unit in let v = tt : Unit in v ⟧
    • actual: C ⟦ let x = tt : Unit in let y = tt : Unit in x ⟧
    • not convertible (at level 0): !1 /= !0
    • When checking that
      Cx
      has type
      C ⟦ let u = tt : Unit in let v = tt : Unit in v ⟧
    • When checking that
      λ Cx ↦ Cx
      has type
      C ⟦ let x = tt : Unit in let y = tt : Unit in x ⟧ →
      C ⟦ let u = tt : Unit in let v = tt : Unit in v ⟧
    • When checking that
      λ _ Cx ↦ Cx
      has type
      Id
        {Code ⟦ Unit ⟧}
        ⟦ let x = tt : Unit in let y = tt : Unit in x ⟧
        ⟦ let u = tt : Unit in let v = tt : Unit in v ⟧
    • When infering type of
      (λ _ Cx ↦ Cx)
        : Id
          {Code ⟦ Unit ⟧}
          ⟦ let x = tt : Unit in let y = tt : Unit in x ⟧
          ⟦ let u = tt : Unit in let v = tt : Unit in v ⟧

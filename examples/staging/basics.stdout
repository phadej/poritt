include "../lib/bool.ptt"

Bool : U
Bool = #[:false :true]

true : Bool
true = :true

false : Bool
false = :false

inline true

inline false

if : Bool → ∀ (A : U) → A → A → A
if = [ (λ _ t f ↦ f) (λ _ t f ↦ t) ]

not : Bool → Bool
not = [ :true :false ]

and : Bool → Bool → Bool
and = [ (λ _ ↦ :false) (λ y ↦ y) ]

or : Bool → Bool → Bool
or = [ (λ y ↦ y) (λ _ ↦ :true) ]

eqBool : Bool → Bool → Bool
eqBool = [ [ :true :false ] [ :false :true ] ]

eqUnit : Unit → Unit → Bool
eqUnit = λ _ _ ↦ :true

end-of-file "../lib/bool.ptt"

include "../lib/leibniz.ptt"

Id : ∀ {A : U} → A → A → U
Id = λ x y ↦ ∀ (C : A → U) → C x → C y

refl : ∀ {A : U} (x : A) → Id x x
refl = λ x C Cx ↦ Cx

macro %refl 
  = λ _ Cx ↦ Cx

sym : ∀ (A : U) (x : A) (y : A) → Id x y → Id y x
sym = λ A x y x=y ↦ x=y (λ z ↦ Id z x) (refl x)

trans : ∀ (A : U) (x : A) (y : A) (z : A) → Id x y → Id y z → Id x z
trans = λ A x y z x=y y=z ↦ y=z (λ v ↦ Id x v) x=y

end-of-file "../lib/leibniz.ptt"

define CodeU : U = Code ⟦ U ⟧

define CU : Code ⟦ U ⟧ = ⟦ U ⟧

define U1 : U = U

define U2 : U = U

define timely : ∀ (A : CodeU) → Code ⟦ ∫A → ∫A ⟧ = λ A ↦ ⟦ λ x ↦ x ⟧

define appE
  : ∀ (A : CodeU) (B : CodeU) → Code ⟦ ∫A → ∫B ⟧ → Code A → Code B
  = λ A B f x ↦ ⟦ ∫f ∫x ⟧

define depAppE
  : ∀
    (A : CodeU) (B : Code ⟦ ∫A → U ⟧) →
    Code ⟦ ∀ (x : ∫A) → ∫B x ⟧ → ∀ (x : Code A) → Code ⟦ ∫B ∫x ⟧
  = λ _ _ f x ↦ ⟦ ∫f ∫x ⟧

define twice
  : ∀ (A : CodeU) → (Code A → Code A) → Code ⟦ ∫A → ∫A ⟧
  = λ A f ↦ ⟦ λ x ↦ ∫(f (f ⟦ x ⟧)) ⟧

twiceid : Code ⟦ Bool → Bool ⟧
twiceid = twice ⟦ Bool ⟧ (λ x ↦ ⟦ not ∫x ⟧)

twiceid1 : Bool → Bool
twiceid1 = λ x ↦ not (not x)

twiceid2 : Bool → Bool
twiceid2 = λ x ↦ not (not x)

type %refl : Id {Code ⟦ Bool ⟧} ⟦ true ⟧ ⟦ true ⟧
  : Id {Code ⟦ Bool ⟧} ⟦ true ⟧ ⟦ true ⟧

Error: examples/staging/basics.ptt:34:6: Couldn't match types
  • expected: C ⟦ not false ⟧
  • actual: C ⟦ true ⟧
  • not convertible (at level 0): not false /= true
  • When checking that Cx has type C ⟦ not false ⟧
  • When checking that λ Cx ↦ Cx has type C ⟦ true ⟧ → C ⟦ not false ⟧
  • When checking that
    λ _ Cx ↦ Cx
    has type
    Id {Code ⟦ Bool ⟧} ⟦ true ⟧ ⟦ not false ⟧
  • When infering type of
    (λ _ Cx ↦ Cx) : Id {Code ⟦ Bool ⟧} ⟦ true ⟧ ⟦ not false ⟧
ExitFailure

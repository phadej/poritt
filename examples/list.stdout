include "lib/list.ptt"

define ListC : U = #[:nil :cons]

define ListF : U → ListC → Desc = λ A ↦ [ `1 (`S A (λ _ ↦ `X `1)) ]

define ListD : U → Desc = λ A ↦ `S ListC (ListF A)

define List : U → U = λ A ↦ μ (ListD A)

define nil : ∀ (A : U) → List A = λ _ ↦ :nil

define cons : ∀ (A : U) → A → List A → List A = λ _ x xs ↦ :cons x xs

macro %nil 
  = con [ :nil ]

macro %cons x xs
  = con [ :cons x xs ]

define foldr
  : ∀ (A : U) (B : U) → (A → B → B) → B → List A → B
  = λ A B consC nilC e ↦
    ind
      e
      (λ _ ↦ B)
      (λ d ↦
         (switch (d .fst) (λ c' ↦
                             ∀
                               (y : evalDesc (ListF A c') (List A)) →
                               All (ListD A) (μ (ListD A)) (λ _ ↦ B) (c' , y) →
                               B)
            {:nil ↦ λ _ _ ↦ nilC; :cons ↦ λ x acc ↦ consC (x .fst) (acc .fst)})
           (d .snd))

define indList
  : ∀
    (A : U) (M : List A → U) →
    M (nil A) →
    (∀ (x : A) (xs : List A) → M xs → M (cons A x xs)) → ∀ (e : List A) → M e
  = λ A M Mnil Mcons e ↦
    ind
      e
      M
      (λ d ↦
         (switch (d .fst) (λ c' ↦
                             ∀
                               (y : evalDesc (ListF A c') (List A)) →
                               All (ListD A) (μ (ListD A)) M (c' , y) →
                               M (con (c' , y)))
            {:nil ↦ λ e' allE ↦ Mnil;
             :cons ↦ λ e' allE ↦ Mcons (e' .fst) (e' .snd .fst) (allE .fst)})
           (d .snd))

end-of-file "examples/lib/list.ptt"

include "lib/bool.ptt"

define Bool : U = #[:false :true]

define true : Bool = :true

define false : Bool = :false

inline true

inline false

define if : Bool → ∀ (A : U) → A → A → A = [ (λ _ t f ↦ f) (λ _ t f ↦ t) ]

define not : Bool → Bool = [ :true :false ]

define and : Bool → Bool → Bool = [ (λ _ ↦ :false) (λ y ↦ y) ]

define or : Bool → Bool → Bool = [ (λ y ↦ y) (λ _ ↦ :true) ]

define eqBool : Bool → Bool → Bool = [ [ :true :false ] [ :false :true ] ]

define eqUnit : Unit → Unit → Bool = λ _ _ ↦ :true

end-of-file "examples/lib/bool.ptt"

define ex
  : List Bool
  = cons
    Bool
    :true
    (cons Bool :false (cons Bool :true (cons Bool :false (nil Bool))))

eval ex
  = :cons :true (:cons :false (:cons :true (:cons :false :nil)))
  : List Bool

define ex'
  : List Bool
  = :cons :true (:cons :false (:cons :true (:cons :false :nil)))

eval ex'
  = :cons :true (:cons :false (:cons :true (:cons :false :nil)))
  : List Bool

eval foldr Bool Bool and :true ex = :false : Bool

eval foldr Bool Bool or :false ex = :true : Bool

define NP
  : ∀ (k : U) → (k → U) → List k → U
  = λ k F ↦ foldr k U (λ x acc ↦ F x × acc) #[:tt]

define nilNP : ∀ (k : U) (F : k → U) → NP k F (nil k) = λ _ _ ↦ :tt

define consNP
  : ∀
    (k : U) (F : k → U) (x : k) →
    F x → ∀ (xs : List k) → NP k F xs → NP k F (cons k x xs)
  = λ k F x fx xs fxs ↦ fx , fxs

define curryFun
  : ∀ (k : U) → (k → U) → List k → U → U
  = λ k F As B ↦ foldr k U (λ x y ↦ F x → y) B As

eval curryFun U (λ x ↦ x) (cons U #[:a :b :c] (cons U #[:x :y :z] (nil U))) Bool
  = #[:a :b :c] → #[:x :y :z] → #[:false :true]
  : U

define curryNP
  : ∀
    (K : U) (F : K → U) (xs : List K) (B : U) →
    (NP K F xs → B) → curryFun K F xs B
  = λ K F xs B ↦
    indList
      K
      (λ xs' ↦ (NP K F xs' → B) → curryFun K F xs' B)
      (λ f ↦ f :tt)
      (λ k ks Mks f x ↦ Mks (λ xs0 ↦ f (x , xs0)))
      xs

eval curryNP U (λ x ↦ x) (cons U #[:a :b :c] (cons U #[:x :y :z] (nil U))) Bool
  = λ f x x0 ↦ f (x , x0 , :tt)
  : (NP U (λ x ↦ x) (cons U #[:a :b :c] (cons U #[:x :y :z] (nil U))) → Bool) →
  curryFun U (λ x ↦ x) (cons U #[:a :b :c] (cons U #[:x :y :z] (nil U))) Bool

end-of-file "examples/list.ptt"


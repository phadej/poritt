include "lib/nat.ptt"

NatC : U
NatC = #[:zero :succ]

NatF : NatC → Desc
NatF = [ `1 (`X `1) ]

NatD : Desc
NatD = `S NatC NatF

Nat : U
Nat = μ NatD

eval Nat = μ (`S #[:zero :succ] [ `1 (`X `1) ]) : U

zero : Nat
zero = :zero

succ : Nat → Nat
succ = λ n ↦ :succ n

one : Nat
one = succ zero

two : Nat
two = succ one

three : Nat
three = succ two

four : Nat
four = succ three

five : Nat
five = succ four

indNat
  : ∀
    (M : Nat → U) →
    M zero → (∀ (n : Nat) → M n → M (succ n)) → ∀ (e : Nat) → M e
indNat
  = λ M Mzero Msucc e ↦
    ind
      e
      M
      (λ d ↦
         (switch (d .fst) (λ c' ↦
                             ∀
                               (y : evalDesc (NatF c') Nat) →
                               All (NatF c') Nat M y → M (con (c' , y)))
            {:zero ↦ λ _ _ ↦ Mzero; :succ ↦ λ n Mn ↦ Msucc (n .fst) (Mn .fst)})
           (d .snd))

iterNat : ∀ (A : U) → A → (A → A) → Nat → A
iterNat = λ A z s ↦ indNat (λ _ ↦ A) z (λ _ n ↦ s n)

paraNat : ∀ (A : U) → A → (Nat → A → A) → Nat → A
paraNat = λ A z s ↦ indNat (λ _ ↦ A) z (λ n a ↦ s n a)

caseNat : Nat → ∀ (A : U) → A → (Nat → A) → A
caseNat = λ m A z s ↦ paraNat A z (λ n _ ↦ s n) m

plus : Nat → Nat → Nat
plus = λ n m ↦ iterNat Nat m succ n

mult : Nat → Nat → Nat
mult = λ n m ↦ iterNat Nat zero (plus m) n

include "bool.ptt"

Bool : U
Bool = #[:false :true]

true : Bool
true = :true

false : Bool
false = :false

inline true

inline false

if : Bool → ∀ (A : U) → A → A → A
if = [ (λ _ t f ↦ f) (λ _ t f ↦ t) ]

not : Bool → Bool
not = [ :true :false ]

and : Bool → Bool → Bool
and = [ (λ _ ↦ :false) (λ y ↦ y) ]

or : Bool → Bool → Bool
or = [ (λ y ↦ y) (λ _ ↦ :true) ]

eqBool : Bool → Bool → Bool
eqBool = [ [ :true :false ] [ :false :true ] ]

eqUnit : Unit → Unit → Bool
eqUnit = λ _ _ ↦ :true

end-of-file "examples/lib/bool.ptt"

isZero : Nat → Bool
isZero = λ n ↦ caseNat n Bool :true (λ _ ↦ :false)

eqNat : Nat → Nat → Bool
eqNat = iterNat (Nat → Bool) isZero (λ rec m ↦ caseNat m Bool :false rec)

end-of-file "examples/lib/nat.ptt"

include "lib/leibniz.ptt"

Id : ∀ {A : U} → A → A → U
Id = λ x y ↦ ∀ (C : A → U) → C x → C y

refl : ∀ {A : U} (x : A) → Id x x
refl = λ x C Cx ↦ Cx

macro %refl 
  = λ _ Cx ↦ Cx

sym : ∀ (A : U) (x : A) (y : A) → Id x y → Id y x
sym = λ A x y x=y ↦ x=y (λ z ↦ Id z x) (refl x)

trans : ∀ (A : U) (x : A) (y : A) (z : A) → Id x y → Id y z → Id x z
trans = λ A x y z x=y y=z ↦ y=z (λ v ↦ Id x v) x=y

end-of-file "examples/lib/leibniz.ptt"

section numbers

eval two = :succ (:succ :zero) : Nat

eval three = :succ (:succ (:succ :zero)) : Nat

section Nat iteration

eval iterNat
  = λ A z s e ↦
    ind
      e
      (λ _ ↦ A)
      (λ d ↦
         (switch (d .fst) (λ c' ↦
                             ∀
                               (y : evalDesc (NatF c') Nat) →
                               All (NatF c') Nat (λ _ ↦ A) y → A)
            {:zero ↦ λ _ _ ↦ z; :succ ↦ λ n Mn ↦ s (Mn .fst)})
           (d .snd))
  : ∀ (A : U) → A → (A → A) → Nat → A

section Arithmetic examples

eval plus two two = :succ (:succ (:succ (:succ :zero))) : Nat

eval mult two three = :succ (:succ (:succ (:succ (:succ (:succ :zero))))) : Nat

eval mult three two = :succ (:succ (:succ (:succ (:succ (:succ :zero))))) : Nat

section Syntax sugar

type :zero : Nat : Nat

type (λ n ↦ :succ n) : Nat → Nat : Nat → Nat

end-of-file "examples/nat.ptt"


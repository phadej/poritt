define ListC : U = #[:nil :cons]

define ListF : U → ListC → Desc = λ A ↦ [ `1 (`S A (λ _ ↦ `X `1)) ]

define ListD : U → Desc = λ A ↦ `S ListC (ListF A)

define List : U → U = λ A ↦ μ (ListD A)

define nil : ∀ (A : U) → List A = λ _ ↦ :nil

define cons : ∀ (A : U) → A → List A → List A = λ _ x xs ↦ :cons x xs

macro %nil 
  = con [ :nil ]

macro %cons x xs
  = con [ :cons x xs ]

define foldr
  : ∀ (A : U) (B : U) → (A → B → B) → B → List A → B
  = λ A B consC nilC e ↦
    ind
      e
      (λ _ ↦ B)
      (λ d ↦
         (switch (d .fst) (λ c' ↦
                             ∀
                               (y : evalDesc (ListF A c') (List A)) →
                               All (ListD A) (μ (ListD A)) (λ _ ↦ B) (c' , y) →
                               B)
            {:nil ↦ λ _ _ ↦ nilC; :cons ↦ λ x acc ↦ consC (x .fst) (acc .fst)})
           (d .snd))

define indList
  : ∀
    (A : U) (M : List A → U) →
    M (nil A) →
    (∀ (x : A) (xs : List A) → M xs → M (cons A x xs)) → ∀ (e : List A) → M e
  = λ A M Mnil Mcons e ↦
    ind
      e
      M
      (λ d ↦
         (switch (d .fst) (λ c' ↦
                             ∀
                               (y : evalDesc (ListF A c') (List A)) →
                               All (ListD A) (μ (ListD A)) M (c' , y) →
                               M (con (c' , y)))
            {:nil ↦ λ e' allE ↦ Mnil;
             :cons ↦ λ e' allE ↦ Mcons (e' .fst) (e' .snd .fst) (allE .fst)})
           (d .snd))

end-of-file "examples/lib/list.ptt"


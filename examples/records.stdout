include "lib/bool.ptt"

Bool : U
Bool = #[:false :true]

true : Bool
true = :true

false : Bool
false = :false

inline true

inline false

if : Bool → ∀ (A : U) → A → A → A
if = [ (λ _ t f ↦ f) (λ _ t f ↦ t) ]

not : Bool → Bool
not = [ :true :false ]

and : Bool → Bool → Bool
and = [ (λ _ ↦ :false) (λ y ↦ y) ]

or : Bool → Bool → Bool
or = [ (λ y ↦ y) (λ _ ↦ :true) ]

eqBool : Bool → Bool → Bool
eqBool = [ [ :true :false ] [ :false :true ] ]

eqUnit : Unit → Unit → Bool
eqUnit = λ _ _ ↦ :true

end-of-file "examples/lib/bool.ptt"

include "lib/nat.ptt"

NatC : U
NatC = #[:zero :succ]

NatF : NatC → Desc
NatF = [ `1 (`X `1) ]

NatD : Desc
NatD = `S NatC NatF

Nat : U
Nat = μ NatD

eval Nat = μ (`S #[:zero :succ] [ `1 (`X `1) ]) : U

zero : Nat
zero = :zero

succ : Nat → Nat
succ = λ n ↦ :succ n

one : Nat
one = succ zero

two : Nat
two = succ one

three : Nat
three = succ two

four : Nat
four = succ three

five : Nat
five = succ four

indNat
  : ∀
    (M : Nat → U) →
    M zero → (∀ (n : Nat) → M n → M (succ n)) → ∀ (e : Nat) → M e
indNat
  = λ M Mzero Msucc e ↦
    ind
      e
      M
      (λ d ↦
         (switch (d .fst) (λ c' ↦
                             ∀
                               (y : evalDesc (NatF c') Nat) →
                               All (NatF c') Nat M y → M (con (c' , y)))
            {:zero ↦ λ _ _ ↦ Mzero; :succ ↦ λ n Mn ↦ Msucc (n .fst) (Mn .fst)})
           (d .snd))

iterNat : ∀ (A : U) → A → (A → A) → Nat → A
iterNat = λ A z s ↦ indNat (λ _ ↦ A) z (λ _ n ↦ s n)

paraNat : ∀ (A : U) → A → (Nat → A → A) → Nat → A
paraNat = λ A z s ↦ indNat (λ _ ↦ A) z (λ n a ↦ s n a)

caseNat : Nat → ∀ (A : U) → A → (Nat → A) → A
caseNat = λ m A z s ↦ paraNat A z (λ n _ ↦ s n) m

plus : Nat → Nat → Nat
plus = λ n m ↦ iterNat Nat m succ n

mult : Nat → Nat → Nat
mult = λ n m ↦ iterNat Nat zero (plus m) n

include "bool.ptt"

end-of-file "examples/lib/bool.ptt"

isZero : Nat → Bool
isZero = λ n ↦ caseNat n Bool :true (λ _ ↦ :false)

eqNat : Nat → Nat → Bool
eqNat = iterNat (Nat → Bool) isZero (λ rec m ↦ caseNat m Bool :false rec)

end-of-file "examples/lib/nat.ptt"

include "lib/list.ptt"

ListC : U
ListC = #[:nil :cons]

ListF : U → ListC → Desc
ListF = λ A ↦ [ `1 (`S A (λ _ ↦ `X `1)) ]

ListD : U → Desc
ListD = λ A ↦ `S ListC (ListF A)

List : U → U
List = λ A ↦ μ (ListD A)

nil : ∀ (A : U) → List A
nil = λ _ ↦ :nil

cons : ∀ (A : U) → A → List A → List A
cons = λ _ x xs ↦ :cons x xs

macro %nil 
  = con [ :nil ]

macro %cons x xs
  = con [ :cons x xs ]

foldr : ∀ (A : U) (B : U) → (A → B → B) → B → List A → B
foldr
  = λ A B consC nilC e ↦
    ind
      e
      (λ _ ↦ B)
      (λ d ↦
         (switch (d .fst) (λ c' ↦
                             ∀
                               (y : evalDesc (ListF A c') (List A)) →
                               All (ListD A) (μ (ListD A)) (λ _ ↦ B) (c' , y) →
                               B)
            {:nil ↦ λ _ _ ↦ nilC; :cons ↦ λ x acc ↦ consC (x .fst) (acc .fst)})
           (d .snd))

indList
  : ∀
    (A : U) (M : List A → U) →
    M (nil A) →
    (∀ (x : A) (xs : List A) → M xs → M (cons A x xs)) → ∀ (e : List A) → M e
indList
  = λ A M Mnil Mcons e ↦
    ind
      e
      M
      (λ d ↦
         (switch (d .fst) (λ c' ↦
                             ∀
                               (y : evalDesc (ListF A c') (List A)) →
                               All (ListD A) (μ (ListD A)) M (c' , y) →
                               M (con (c' , y)))
            {:nil ↦ λ e' allE ↦ Mnil;
             :cons ↦ λ e' allE ↦ Mcons (e' .fst) (e' .snd .fst) (allE .fst)})
           (d .snd))

end-of-file "examples/lib/list.ptt"

include "lib/leibniz.ptt"

Id : ∀ {A : U} → A → A → U
Id = λ x y ↦ ∀ (C : A → U) → C x → C y

refl : ∀ {A : U} (x : A) → Id x x
refl = λ x C Cx ↦ Cx

macro %refl 
  = λ _ Cx ↦ Cx

sym : ∀ (A : U) (x : A) (y : A) → Id x y → Id y x
sym = λ A x y x=y ↦ x=y (λ z ↦ Id z x) (refl x)

trans : ∀ (A : U) (x : A) (y : A) (z : A) → Id x y → Id y z → Id x z
trans = λ A x y z x=y y=z ↦ y=z (λ v ↦ Id x v) x=y

end-of-file "examples/lib/leibniz.ptt"

section Records

define RecDef : U = ∃ (A : U) × (A → U)

define mkRecord : RecDef → U = λ def ↦ ∀ (field : def .fst) → def .snd field

Foo : U
Foo = mkRecord [ #[:foo :bar :quu] Bool Nat Unit ]

define foo1 : Foo = [ :true two [] ]

define foo2 : Foo = [ :true three [] ]

type %refl : Id {Nat} (foo1 :bar) two : Id (foo1 :bar) two

section Equality

define eqFoo
  : Foo → Foo → Bool
  = λ x y ↦
    and
      (eqBool (x :foo) (y :foo))
      (and (eqNat (x :bar) (y :bar)) (and (eqUnit (x :quu) (y :quu)) :true))

section NP generics

define I : U → U = λ x ↦ x

define NP
  : ∀ (k : U) → (k → U) → List k → U
  = λ k F ↦ foldr k U (λ x acc ↦ F x × acc) Unit

define Generic
  : U → U
  = λ A ↦ ∃ (desc : List U) × (A → NP U I desc) × (NP U I desc → A)

define genericEq'
  : ∀
    (xs : List U) → NP U (λ x ↦ x → x → Bool) xs → NP U I xs → NP U I xs → Bool
  = indList
    U
    (λ ys ↦ NP U (λ x ↦ x → x → Bool) ys → NP U I ys → NP U I ys → Bool)
    (λ es ls rs ↦ :true)
    (λ z zs rec es ls rs ↦
       and (es .fst (ls .fst) (rs .fst)) (rec (es .snd) (ls .snd) (rs .snd)))

define genericEq
  : ∀
    (A : U) (g : Generic A) → NP U (λ x ↦ x → x → Bool) (g .fst) → A → A → Bool
  = λ _ g eq x y ↦ genericEq' (g .fst) eq (g .snd .fst x) (g .snd .fst y)

section Generic Foo equality

define FooDesc : List U = :cons Bool (:cons Nat (:cons Unit :nil))

define fromFoo : Foo → NP U I FooDesc = λ x ↦ [ (x :foo) (x :bar) (x :quu) ]

define toFoo
  : NP U I FooDesc → Foo
  = λ x ↦ [ (x .fst) (x .snd .fst) (x .snd .snd .fst) ]

define GenericFoo : Generic Foo = FooDesc , fromFoo , toFoo

define eqFooG
  : Foo → Foo → Bool
  = genericEq Foo GenericFoo [ eqBool eqNat eqUnit ]

section Staged NP-generics

define CodeU : U = Code ⟦ U ⟧

define C : CodeU → U = λ x ↦ Code x

define Staged
  : U → U
  = λ A ↦
    ∃
      (CA : CodeU) (desc : List CodeU) ×
      (Code CA → ∀ (r : CodeU) → (NP CodeU C desc → Code r) → Code r) ×
      (NP CodeU C desc → Code CA)

define stagedEq'
  : ∀
    (xs : List CodeU) →
    NP CodeU (λ x ↦ Code ⟦ $x → $x → Bool ⟧) xs →
    NP CodeU C xs → NP CodeU C xs → C ⟦ Bool ⟧
  = indList
    CodeU
    (λ ys ↦
       NP CodeU (λ x ↦ Code ⟦ $x → $x → Bool ⟧) ys →
       NP CodeU C ys → NP CodeU C ys → C ⟦ Bool ⟧)
    (λ _ _ _ ↦ ⟦ :1 ⟧)
    (λ z zs rec es ls rs ↦
       ⟦ and
         ($(es .fst) $(ls .fst) $(rs .fst))
         $(rec (es .snd) (ls .snd) (rs .snd)) ⟧)

define stagedEq
  : ∀
    (A : U) (g : Staged A) →
    NP CodeU (λ x ↦ Code ⟦ $x → $x → Bool ⟧) (g .snd .fst) →
    Code (g .fst) → Code (g .fst) → Code ⟦ Bool ⟧
  = λ _ g eq x y ↦
    g
      .snd
      .snd
      .fst
      x
      ⟦ Bool ⟧
      (λ x' ↦
         g .snd .snd .fst y ⟦ Bool ⟧ (λ y' ↦ stagedEq' (g .snd .fst) eq x' y'))

section Staged Foo equality

define FooCodeDesc
  : List CodeU
  = con (:1 , ⟦ Bool ⟧ , con (:1 , ⟦ Nat ⟧ , con (:1 , ⟦ Unit ⟧ , con (:0 , tt) , tt) , tt) , tt)

define sfromFoo
  : Code ⟦ Foo ⟧ → ∀ (r : CodeU) → (NP CodeU C FooCodeDesc → Code r) → Code r
  = λ x _r kont ↦ kont (⟦ $x :0 ⟧ , ⟦ $x :1 ⟧ , ⟦ $x :2 ⟧ , tt)

define stoFoo
  : NP CodeU C FooCodeDesc → Code ⟦ Foo ⟧
  = λ x ↦
    ⟦ λ field ↦
      switch field (λ field0 ↦
                      switch field0 (λ ds ↦ U) {:0 ↦ Bool; :1 ↦ Nat; :2 ↦ Unit})
        {:0 ↦ $(x .fst); :1 ↦ $(x .snd .fst); :2 ↦ $(x .snd .snd .fst)} ⟧

define StagedFoo : Staged Foo = ⟦ Foo ⟧ , FooCodeDesc , sfromFoo , stoFoo

define eqFooS
  : Foo → Foo → Bool
  = λ x y ↦
    and
      (eqBool (x :foo) (y :foo))
      (and (eqNat (x :bar) (y :bar)) (and (eqUnit (x :quu) (y :quu)) :true))

section Tests

type %refl : Id {Foo → Foo → Bool} eqFoo eqFooS : Id eqFoo eqFooS

type %refl : Id {Foo → Foo → Bool} eqFoo eqFooG : Id eqFoo eqFooG

type %refl : Id {Bool} (eqFoo foo1 foo1) :true : Id (eqFoo foo1 foo1) :true

type %refl : Id {Bool} (eqFooS foo1 foo1) :true : Id (eqFooS foo1 foo1) :true

type %refl : Id {Bool} (eqFooG foo1 foo1) :true : Id (eqFooG foo1 foo1) :true

type %refl : Id {Bool} (eqFoo foo1 foo2) :false : Id (eqFoo foo1 foo2) :false

type %refl : Id {Bool} (eqFooS foo1 foo2) :false : Id (eqFooS foo1 foo2) :false

type %refl : Id {Bool} (eqFooG foo1 foo2) :false : Id (eqFooG foo1 foo2) :false

end-of-file "examples/records.ptt"

